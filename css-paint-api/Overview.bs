<pre class='metadata'>
Title:  CSS Painting API Level 1
Status: DREAM
ED: http://dev.w3.org/houdini/css-paint-api/
Shortname: css-paint-api
Level: 1
Abstract: Elements that are styled by CSS respond to changes in laid out size and CSS property values by repainting their contents and background. This API allows the default paint algorithm for CSS-styled elements to be replaced by custom JavaScript code.
Editor: Shane Stephens, shanestephens@google.com
Editor: Ian Kilpatrick, ikilpatrick@chromium.org
Editor: Dean Jackson, dino@apple.com
</pre>

<h2 id='introduction'>Introduction</h2>

The paint stage of CSS is responsible for painting the background, content and
highlight of an element based on that element's geometry (as generated by the
layout stage) and computed style.

This specification describes an API that allows developers to replace the
default paint algorithm for CSS-styled elements with a custom JavaScript
implementation.

Issue: where in the elaborate description of stacking contexts should this
insert? Do we need 2 insertion points (background and content)? 3 (highlight)?
Should we therefore have multiple versions of the 'paint' property? HALP

<h2 id='the-paint-callback-lifecycle'>The Paint Callback Lifecycle</h2>

Elements with paint callbacks have style computed and are laid out in 
the normal way. The act of performing layout generates geometry information
which is fed into the paint callback as an input argument. Paint callbacks
also identify properties to which they are sensitive as part of registration.
The computed value of these properties are also provide to the paint callback
on invocation.

<h3 id='Invalidation'>Invalidation</h3>

At any given point in time, elements with paint callbacks are either
<dfn>paint-valid</dfn> or <dfn>paint-invalid</dfn>. Paint-invalid elements are
guaranteed to have their associated paint callback invoked before any region of
the rendered output of the page that overlaps the element is updated.

Issue: ew. Can we come up with a nicer description of this guarantee?

Invoking an element's paint callback causes that element to become paint-valid.

Paint-valid elements become paint-invalid when one of the following occurs:
 *  the geometry of the element (as determined by a layout) changes
 *  the computed style of a property that the paint callback has registered a
    dependency on changes

Paint-invalid elements' paint callbacks are not necessarily invoked on the
current frame (for example, elements outside of the current visual viewport may
not repaint even if dirty).

Paint-validity does not guarantee that an element's paint callback is not
invoked. Browsers may choose to call paint-valid elements' paint callbacks for
simplicity. Thus to ensure cross-browser interoperability, registered paint
callbacks should be idempotent.

<h2 id='registering-a-paint-callback'>Registering a Paint Callback</h2>

Elements are associated with a paint callback via the use of the 'paint' property.

 <pre class='propdef'>
    Name: paint
    Value: none | &lt;IDENT&gt;
    Initial: none
    Applies To: all elements and pseudo-elements
    Inherited: no
    Animatable: no
    Media: visual
    Computed Value: As specified
</pre>

Issue: should paint apply to more media than just visual? Or should we just
rely on the accessibility APIs here?

Issue: should it be possible to support multiple paint callbacks?

When a value other than none is specified, then this value represents a
lookup into the <a>paint callback table</a>.

<h3 id='the-paint-callback-table'>The Paint Callback Table</h3>

The <dfn>paint callback table</dfn> is a dictionary of <a>paint callbacks</a>,
initialized and maintained by JavaScript. A single method is available to
configure this table:

<pre class='idl'>
partial interface Document {
    void registerCustomPaint(DOMString callbackName, PaintCallback paintCallback);
};
</pre>

Multiple calls to {{registerCustomPaint()}} override previous registrations. A
name can be dissociated from a callback by calling {{registerCustomPaint()}}
with a null <a>paint callback</a>.

<h2 id='isolated-javascript-execution'>Isolated JavaScript Execution</h2>

Issue: everything here needs to be defined. This might use realms, or a special
worker. It's important that the thread affinity here is implementor-definable.

<h2 id='paint-callbacks'>Paint Callbacks</h2>

<dfn>paint callback</dfn>

<pre class='idl'>
dictionary PropertyDictionary {
    // key-value pairs...
};

interface GeometryInfo {
    readonly attribute double width;
    readonly attribute double height;
    // TODO: Fragment information
};

interface WriteOnlyCanvas {
};

callback PaintCallbackType = void (GeometryInfo geometry, PropertyDictionary properties, WriteOnlyCanvas canvas);

interface PaintCallback {
    attribute PaintCallbackType paintCallback;
    attribute sequence&lt;DOMString&gt; properties;
};
</pre>

Issue: paintCallback won't be a simple function, but will depend on how <a
href='#the-paint-callback-table' section></a> ends up being defined.

Issue: Do we need to be able to specify up-front what kind of context will be
used for performance reasons?

Issue: is GeometryInfo just box tree's DeadFragmentInformation?

Issue: how do we transfer in bitmapped data?

<h2>Overriding clipping, transform and opacity</h2>

Issue: TODO
